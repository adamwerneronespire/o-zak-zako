FUNCTION /ZAK/AFA_ALAP_VERIFY.
*"----------------------------------------------------------------------
*"*Local interface:
*"  IMPORTING
*"     VALUE(I_DATA) LIKE  /ZAK/AFALAPVERIF STRUCTURE
*"        /ZAK/AFALAPVERIF
*"  CHANGING
*"     VALUE(E_DATA) LIKE  /ZAK/AFALAPVERIF STRUCTURE
*"        /ZAK/AFALAPVERIF OPTIONAL
*"  EXCEPTIONS
*"      ERROR_INPUT_DATA
*"----------------------------------------------------------------------
*++ BG 2007.09.24
* DATA LWBAS_EXACT TYPE I.
  DATA LWBAS_EXACT(15) TYPE P DECIMALS 0.
*-- BG 2007.09.24
  DATA LINTER  TYPE I.
  DATA LTEXT(40).
  DATA LW_DATA LIKE /ZAK/AFALAPVERIF.
  DATA LFLAG.

  DEFINE M_GET_PACK_TO_NUM.
    CLEAR LTEXT.
    WRITE &1 CURRENCY &2 TO LTEXT NO-GROUPING
                                  LEFT-JUSTIFIED.
    REPLACE ',' WITH '.' INTO LTEXT.
    &3 = LTEXT.
  END-OF-DEFINITION.

  DATA: L_ROUND(20) TYPE C.

  DEFINE M_ROUND.
    IF NOT I_DATA-ROUND IS INITIAL.
      WRITE &1 TO L_ROUND
          ROUND I_DATA-ROUND NO-GROUPING.
      REPLACE ',' WITH '.' INTO L_ROUND.
      &1 = L_ROUND.
      &1 = &1 * ( 10 ** I_DATA-ROUND ).
    ENDIF.
  END-OF-DEFINITION.


  CLEAR E_DATA.

* If any INPUT data is missing.
  IF I_DATA-LWBAS IS INITIAL OR I_DATA-LWSTE IS INITIAL OR
     I_DATA-WAERS IS INITIAL OR I_DATA-KBETR IS INITIAL.
    RAISE ERROR_INPUT_DATA.
  ENDIF.

* Transfer data
  CLEAR LW_DATA.

* Convert data:
  M_GET_PACK_TO_NUM: I_DATA-LWBAS I_DATA-WAERS LW_DATA-LWBAS,
                     I_DATA-LWSTE I_DATA-WAERS LW_DATA-LWSTE.

* Determine exact value
  LWBAS_EXACT =  LW_DATA-LWSTE / ( I_DATA-KBETR / 100 ).

* Intervallum
  LINTER = ( 1 / ( I_DATA-KBETR / 100 ) ) - 1.

*++BG 2009.11.26
  LINTER = LINTER  * ( 10 ** I_DATA-ROUND ).
*--BG 2009.11.26


* Interval values
*++BG 2009.11.26
*  LW_DATA-LWBAS_LOW  = LWBAS_EXACT - ( LINTER / 2 + 1 ).
*  LW_DATA-LWBAS_HIGH = LWBAS_EXACT + ( LINTER / 2 + 1 ).
LW_DATA-LWBAS_LOW  = LWBAS_EXACT - ( LINTER / 2 + 10 ** I_DATA-ROUND ).
LW_DATA-LWBAS_HIGH = LWBAS_EXACT + ( LINTER / 2 + 10 ** I_DATA-ROUND ).
*--BG 2009.11.26


* Round the exact value if necessary
  M_ROUND LWBAS_EXACT.

* Pass values to EXPORT:
  E_DATA = I_DATA.

* Lower bound:
  CLEAR LFLAG.
  IF LW_DATA-LWBAS_LOW < 0.
    MOVE '-' TO LFLAG.
    LW_DATA-LWBAS_LOW = ABS( LW_DATA-LWBAS_LOW ).
  ENDIF.

  CALL FUNCTION '/ZAK/CONVERT_STRING_TO_PACKED'
    EXPORTING
      I_AMOUNT        = LW_DATA-LWBAS_LOW
      I_CURRENCY_CODE = E_DATA-WAERS
    IMPORTING
      E_AMOUNT        = E_DATA-LWBAS_LOW.

  IF LFLAG = '-'.
    MULTIPLY E_DATA-LWBAS_LOW BY -1.
  ENDIF.



* Upper bound:
  CLEAR LFLAG.
  IF LW_DATA-LWBAS_HIGH < 0.
    MOVE '-' TO LFLAG.
    LW_DATA-LWBAS_HIGH = ABS( LW_DATA-LWBAS_HIGH ).
  ENDIF.

  CALL FUNCTION '/ZAK/CONVERT_STRING_TO_PACKED'
    EXPORTING
      I_AMOUNT        = LW_DATA-LWBAS_HIGH
      I_CURRENCY_CODE = E_DATA-WAERS
    IMPORTING
      E_AMOUNT        = E_DATA-LWBAS_HIGH.

  IF LFLAG = '-'.
    MULTIPLY E_DATA-LWBAS_HIGH BY -1.
  ENDIF.

* Ha nincs benne van az intervallumban:
  IF NOT E_DATA-LWBAS BETWEEN E_DATA-LWBAS_LOW AND E_DATA-LWBAS_HIGH.
    MOVE 'X' TO E_DATA-LWBAS_FLAG.

    E_DATA-LWBAS_CORR = LWBAS_EXACT - LW_DATA-LWBAS.

    CLEAR LFLAG.
    IF E_DATA-LWBAS_CORR < 0.
      MOVE '-' TO LFLAG.
      E_DATA-LWBAS_CORR = ABS( E_DATA-LWBAS_CORR ).
    ENDIF.

    CALL FUNCTION '/ZAK/CONVERT_STRING_TO_PACKED'
      EXPORTING
        I_AMOUNT        = E_DATA-LWBAS_CORR
        I_CURRENCY_CODE = E_DATA-WAERS
      IMPORTING
        E_AMOUNT        = E_DATA-LWBAS_CORR.

    IF LFLAG = '-'.
      MULTIPLY E_DATA-LWBAS_CORR BY -1.
    ENDIF.

  ENDIF.


ENDFUNCTION.
